/*
 * ---------
 * Module Name: RectangularKeyTransposition.java
 * Generates a key based on the key provided. It then uses this new key as a substitution key.
 * e.g. key -> wihmlz
 * The program takes in this key <wihmlz>, and returns <wagqxibjryhcksmdntleouzfpv>.
 * This is obtained by taking <w i h m l z>, adding the missing letters of the alphabet <abcdefgjknopqrstuvxy> to it,
 * and forming a rectangle (of width key.length) out of it, like so:
 *                  w i h m l z
 *                  a b c d e f
 *                  g j k n o p
 *                  q r s t u v
 *                  x y
 * The key is generated by reading vertically from left to right: wagqxibjryhcksmdntleouzfpv
 *
 * This new key is then used to perform substitution on the plaintext, where:
 *      PT: a b c d e f g h i j k l m n o p q r s t u v w x y z
 *      CT: w a g q x i b j r y h c k s m d n t l e o u z f p v
 * ---------
 * @params: plaintext/ciphertext -> the text to be encrypted/decrypted.
 *          key -> the key to use to perform the encryption/decryption.
 * ---------
 */

package modules;

import com.Cipher;
import com.InvalidKeyException;
import com.Utility;

import java.util.ArrayList;
import java.util.List;

public class RectangularKeyTransposition implements Cipher {
	@Override
	public String encrypt(String plaintext, String key) throws InvalidKeyException {
		key = key.toLowerCase();
		checkKey(key);

		key = generateOTP(key);
		System.out.println("key = " + key);
		Cipher sub = new Substitution();

		return sub.encrypt(plaintext, key);
	}

	@Override
	public String decrypt(String ciphertext, String key) throws InvalidKeyException {
		key = key.toLowerCase();
		checkKey(key);

		key = generateOTP(key);
		Cipher sub = new Substitution();

		return sub.decrypt(ciphertext, key);
	}

	@Override
	public String getDescription() {
		return null;
	}

	@Override
	public String getName() {
		return null;
	}

	private String generateOTP (String key) {
		List<List<Character>> rectangle = new ArrayList<>();
		StringBuilder out = new StringBuilder(key);
		for (Character c: Utility.alphabet.toCharArray()) {
			if (!out.toString().contains(c.toString())) {
				out.append(c);
			}
		}

		System.out.println("out.toString() = " + out.toString());

		List<Character> row = new ArrayList<>();
		for (Character c: out.toString().toCharArray()) {
			row.add(c);

			if (row.size() >= key.length()) {
				rectangle.add(row);
				row = new ArrayList<>();
			}
		}

		if (row.size() != 0)
			rectangle.add(row);

		out = new StringBuilder();
		rectangle = flip(rectangle);
		for (List<Character> r: rectangle) {
			for (Character c: r) {
				out.append(c);
			}
		}

		return out.toString();
	}

	@Override
	public Boolean checkKey(String key) throws InvalidKeyException {
		//not sure if i should do this or allow duplicates and remove them myself.
		if (Utility.removeDuplicates(key).length() != key.length())
			throw new InvalidKeyException("Key cannot have duplicates!");

		if (key.length() < 2)
			throw new InvalidKeyException("Key is too short!");

		return true;
	}

	private List<List<Character>> flip(List<List<Character>> input) {
		List<List<Character>> output = new ArrayList<>();
		List<Character> newRow;

		int maxCols = input.get(0).size();

		for (int i = 0; i < maxCols; ++i) {
			newRow = new ArrayList<>();

			for (List<Character> row : input) {
				if (i < row.size())
					newRow.add(row.get(i));
			}

			output.add(newRow);
		}

		return output;
	}
}
